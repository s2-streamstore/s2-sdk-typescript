// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | 'https://{basin}.b.aws.s2.dev/v1' | (string & {});
};

export type AccessTokenIdStr = string;

export type AccessTokenInfo = {
    /**
     * Namespace streams based on the configured stream-level scope, which must be a prefix.
     * Stream name arguments will be automatically prefixed, and the prefix will be stripped when listing streams.
     */
    auto_prefix_streams?: boolean;
    /**
     * Expiration time in RFC 3339 format.
     * If not set, the expiration will be set to that of the requestor's token.
     */
    expires_at?: string | null;
    /**
     * Access token ID.
     * It must be unique to the account and between 1 and 96 bytes in length.
     */
    id: AccessTokenIdStr;
    /**
     * Access token scope.
     */
    scope: AccessTokenScope;
};

export type AccessTokenScope = {
    access_tokens?: null | ResourceSet;
    basins?: null | ResourceSet;
    op_groups?: null | PermittedOperationGroups;
    /**
     * Operations allowed for the token.
     * A union of allowed operations and groups is used as an effective set of allowed operations.
     */
    ops?: Array<Operation> | null;
    streams?: null | ResourceSet;
};

export type AccountMetricSet = 'active-basins' | 'account-ops';

export type AccumulationMetric = {
    /**
     * The interval at which data points are accumulated.
     */
    interval: TimeseriesInterval;
    /**
     * Timeseries name.
     */
    name: string;
    /**
     * Unit of the metric.
     */
    unit: MetricUnit;
    /**
     * Timeseries values.
     * Each element is a tuple of a timestamp in Unix epoch seconds and a data point.
     * The data point represents the accumulated value for the time period starting at the timestamp, spanning one `interval`.
     */
    values: Array<[
        number,
        number
    ]>;
};

/**
 * Success response to an `append` request.
 */
export type AppendAck = {
    /**
     * Sequence number of the last record that was appended `+ 1`, and timestamp of the last record that was appended.
     * The difference between `end.seq_num` and `start.seq_num` will be the number of records appended.
     */
    end: StreamPosition;
    /**
     * Sequence number and timestamp of the first record that was appended.
     */
    start: StreamPosition;
    /**
     * Sequence number that will be assigned to the next record on the stream, and timestamp of the last record on the stream.
     * This can be greater than the `end` position in case of concurrent appends.
     */
    tail: StreamPosition;
};

/**
 * Aborted due to a failed condition.
 */
export type AppendConditionFailed = {
    /**
     * Fencing token did not match.
     * The expected fencing token is returned.
     */
    fencing_token_mismatch: FencingToken;
} | {
    /**
     * Sequence number did not match the tail of the stream.
     * The expected next sequence number is returned.
     */
    seq_num_mismatch: U64;
};

/**
 * Payload of an `append` request.
 */
export type AppendInput = {
    fencing_token?: null | FencingToken;
    match_seq_num?: null | U64;
    /**
     * Batch of records to append atomically, which must contain at least one record, and no more than 1000.
     * The total size of a batch of records may not exceed 1 MiB of metered bytes.
     */
    records: Array<AppendRecord>;
};

/**
 * Record to be appended to a stream.
 */
export type AppendRecord = {
    /**
     * Body of the record.
     */
    body?: string;
    /**
     * Series of name-value pairs for this record.
     */
    headers?: Array<Header>;
    timestamp?: null | U64;
};

export type BasinConfig = {
    /**
     * Create stream on append if it doesn't exist, using the default stream configuration.
     */
    create_stream_on_append?: boolean;
    /**
     * Create stream on read if it doesn't exist, using the default stream configuration.
     */
    create_stream_on_read?: boolean;
    default_stream_config?: null | StreamConfig;
};

export type BasinInfo = {
    /**
     * Basin name.
     */
    name: BasinNameStr;
    scope?: null | BasinScope;
    /**
     * Basin state.
     */
    state: BasinState;
};

export type BasinMetricSet = 'storage' | 'append-ops' | 'read-ops' | 'read-throughput' | 'append-throughput' | 'basin-ops';

export type BasinNameStr = string;

export type BasinReconfiguration = {
    /**
     * Create a stream on append.
     */
    create_stream_on_append?: boolean | null;
    /**
     * Create a stream on read.
     */
    create_stream_on_read?: boolean | null;
    default_stream_config?: null | StreamReconfiguration;
};

export type BasinScope = 'aws:us-east-1';

export type BasinState = 'active' | 'creating' | 'deleting';

export type CreateBasinRequest = {
    /**
     * Basin name which must be globally unique.
     * It can be between 8 and 48 bytes in length, and comprise lowercase letters, numbers and hyphens.
     * It cannot begin or end with a hyphen.
     */
    basin: BasinNameStr;
    config?: null | BasinConfig;
    scope?: null | BasinScope;
};

export type CreateOrReconfigureBasinRequest = {
    config?: null | BasinConfig;
    scope?: null | BasinScope;
};

export type CreateStreamRequest = {
    config?: null | StreamConfig;
    /**
     * Stream name that is unique to the basin.
     * It can be between 1 and 512 bytes in length.
     */
    stream: StreamNameStr;
};

export type DeleteOnEmptyConfig = {
    /**
     * Minimum age in seconds before an empty stream can be deleted.
     * Set to 0 (default) to disable delete-on-empty (don't delete automatically).
     */
    min_age_secs?: number;
};

export type DeleteOnEmptyReconfiguration = {
    /**
     * Minimum age in seconds before an empty stream can be deleted.
     * Set to 0 to disable delete-on-empty (don't delete automatically).
     */
    min_age_secs?: number | null;
};

export type ErrorInfo = {
    code: string;
    message: string;
};

export type FencingToken = string;

export type Format = 'raw' | 'base64';

export type GaugeMetric = {
    /**
     * Timeseries name.
     */
    name: string;
    /**
     * Unit of the metric.
     */
    unit: MetricUnit;
    /**
     * Timeseries values.
     * Each element is a tuple of a timestamp in Unix epoch seconds and a data point.
     * The data point represents the value at the instant of the timestamp.
     */
    values: Array<[
        number,
        number
    ]>;
};

/**
 * Headers add structured information to a record as name-value pairs.
 *
 * The name cannot be empty, with the exception of an S2 command record.
 */
export type Header = [
    string,
    string
];

export type InfiniteRetention = {
    [key: string]: unknown;
};

export type IssueAccessTokenResponse = {
    /**
     * Created access token.
     */
    access_token: string;
};

export type LabelMetric = {
    /**
     * Label name.
     */
    name: string;
    /**
     * Label values.
     */
    values: Array<string>;
};

export type ListAccessTokensResponse = {
    /**
     * Matching access tokens.
     */
    access_tokens: Array<AccessTokenInfo>;
    /**
     * Indicates that there are more access tokens that match the criteria.
     */
    has_more: boolean;
};

export type ListBasinsResponse = {
    /**
     * Matching basins.
     */
    basins: Array<BasinInfo>;
    /**
     * Indicates that there are more basins that match the criteria.
     */
    has_more: boolean;
};

export type ListStreamsResponse = {
    /**
     * Indicates that there are more results that match the criteria.
     */
    has_more: boolean;
    /**
     * Matching streams.
     */
    streams: Array<StreamInfo>;
};

export type Metric = {
    /**
     * Single named value.
     */
    scalar: ScalarMetric;
} | {
    /**
     * Named series of `(timestamp, value)` points representing an accumulation over a specified interval.
     */
    accumulation: AccumulationMetric;
} | {
    /**
     * Named series of `(timestamp, value)` points each representing an instantaneous value.
     */
    gauge: GaugeMetric;
} | {
    /**
     * Set of string labels.
     */
    label: LabelMetric;
};

export type MetricSetResponse = {
    /**
     * Metrics comprising the set.
     */
    values: Array<Metric>;
};

export type MetricUnit = 'bytes' | 'operations';

export type Operation = 'list-basins' | 'create-basin' | 'delete-basin' | 'reconfigure-basin' | 'get-basin-config' | 'issue-access-token' | 'revoke-access-token' | 'list-access-tokens' | 'list-streams' | 'create-stream' | 'delete-stream' | 'get-stream-config' | 'reconfigure-stream' | 'check-tail' | 'append' | 'read' | 'trim' | 'fence' | 'account-metrics' | 'basin-metrics' | 'stream-metrics';

export type PermittedOperationGroups = {
    account?: null | ReadWritePermissions;
    basin?: null | ReadWritePermissions;
    stream?: null | ReadWritePermissions;
};

export type PingEventData = {
    timestamp: number;
};

export type ReadBatch = {
    /**
     * Records that are durably sequenced on the stream, retrieved based on the requested criteria.
     * This can only be empty in response to a unary read (i.e. not SSE), if the request cannot be satisfied without violating an explicit bound (`count`, `bytes`, or `until`).
     */
    records: Array<SequencedRecord>;
    tail?: null | StreamPosition;
};

export type ReadEvent = {
    data: ReadBatch;
    event: 'batch';
    id: string;
} | {
    data: string;
    event: 'error';
} | {
    data: PingEventData;
    event: 'ping';
};

export type ReadWritePermissions = {
    /**
     * Read permission.
     */
    read?: boolean;
    /**
     * Write permission.
     */
    write?: boolean;
};

export type ResourceSet = {
    /**
     * Match only the resource with this exact name.
     * Use an empty string to match no resources.
     */
    exact: string;
} | {
    /**
     * Match all resources that start with this prefix.
     * Use an empty string to match all resource.
     */
    prefix: string;
};

export type RetentionPolicy = {
    /**
     * Age in seconds for automatic trimming of records older than this threshold.
     * This must be set to a value greater than 0 seconds.
     */
    age: number;
} | {
    /**
     * Retain records unless explicitly trimmed.
     */
    infinite: InfiniteRetention;
};

export type ScalarMetric = {
    /**
     * Metric name.
     */
    name: string;
    /**
     * Unit of the metric.
     */
    unit: MetricUnit;
    /**
     * Metric value.
     */
    value: number;
};

/**
 * Record that is durably sequenced on a stream.
 */
export type SequencedRecord = {
    /**
     * Body of the record.
     */
    body?: string;
    /**
     * Series of name-value pairs for this record.
     */
    headers?: Array<Header>;
    /**
     * Sequence number assigned by the service.
     */
    seq_num: U64;
    /**
     * Timestamp for this record.
     */
    timestamp: U64;
};

export type StorageClass = 'standard' | 'express';

export type StreamConfig = {
    delete_on_empty?: null | DeleteOnEmptyConfig;
    retention_policy?: null | RetentionPolicy;
    storage_class?: null | StorageClass;
    timestamping?: null | TimestampingConfig;
};

export type StreamInfo = {
    /**
     * Creation time in RFC 3339 format.
     */
    created_at: string;
    /**
     * Deletion time in RFC 3339 format, if the stream is being deleted.
     */
    deleted_at?: string | null;
    /**
     * Stream name.
     */
    name: StreamNameStr;
};

export type StreamMetricSet = 'storage';

export type StreamNameStr = string;

/**
 * Position of a record in a stream.
 */
export type StreamPosition = {
    /**
     * Sequence number assigned by the service.
     */
    seq_num: U64;
    /**
     * Timestamp, which may be client-specified or assigned by the service.
     * If it is assigned by the service, it will represent milliseconds since Unix epoch.
     */
    timestamp: U64;
};

export type StreamReconfiguration = {
    delete_on_empty?: null | DeleteOnEmptyReconfiguration;
    retention_policy?: null | RetentionPolicy;
    storage_class?: null | StorageClass;
    timestamping?: null | TimestampingReconfiguration;
};

export type TailResponse = {
    /**
     * Sequence number that will be assigned to the next record on the stream, and timestamp of the last record.
     */
    tail: StreamPosition;
};

export type TimeseriesInterval = 'minute' | 'hour' | 'day';

export type TimestampingConfig = {
    mode?: null | TimestampingMode;
    /**
     * Allow client-specified timestamps to exceed the arrival time.
     * If this is `false` or not set, client timestamps will be capped at the arrival time.
     */
    uncapped?: boolean | null;
};

export type TimestampingMode = 'client-prefer' | 'client-require' | 'arrival';

export type TimestampingReconfiguration = {
    mode?: null | TimestampingMode;
    /**
     * Allow client-specified timestamps to exceed the arrival time.
     */
    uncapped?: boolean | null;
};

export type U64 = number;

export type ListAccessTokensData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter to access tokens whose ID begins with this prefix.
         */
        prefix?: string;
        /**
         * Filter to access tokens whose ID lexicographically starts after this string.
         */
        start_after?: string;
        /**
         * Number of results, up to a maximum of 1000.
         */
        limit?: number;
    };
    url: '/access-tokens';
};

export type ListAccessTokensErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    408: ErrorInfo;
};

export type ListAccessTokensError = ListAccessTokensErrors[keyof ListAccessTokensErrors];

export type ListAccessTokensResponses = {
    200: ListAccessTokensResponse;
};

export type ListAccessTokensResponse2 = ListAccessTokensResponses[keyof ListAccessTokensResponses];

export type IssueAccessTokenData = {
    body: AccessTokenInfo;
    path?: never;
    query?: never;
    url: '/access-tokens';
};

export type IssueAccessTokenErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
};

export type IssueAccessTokenError = IssueAccessTokenErrors[keyof IssueAccessTokenErrors];

export type IssueAccessTokenResponses = {
    201: IssueAccessTokenResponse;
};

export type IssueAccessTokenResponse2 = IssueAccessTokenResponses[keyof IssueAccessTokenResponses];

export type RevokeAccessTokenData = {
    body?: never;
    path: {
        /**
         * Access token ID.
         */
        id: AccessTokenIdStr;
    };
    query?: never;
    url: '/access-tokens/{id}';
};

export type RevokeAccessTokenErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    408: ErrorInfo;
};

export type RevokeAccessTokenError = RevokeAccessTokenErrors[keyof RevokeAccessTokenErrors];

export type RevokeAccessTokenResponses = {
    200: unknown;
};

export type ListBasinsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter to basins whose names begin with this prefix.
         */
        prefix?: string;
        /**
         * Filter to basins whose names lexicographically start after this string.
         * It must be greater than or equal to the `prefix` if specified.
         */
        start_after?: string;
        /**
         * Number of results, up to a maximum of 1000.
         */
        limit?: number;
    };
    url: '/basins';
};

export type ListBasinsErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    408: ErrorInfo;
};

export type ListBasinsError = ListBasinsErrors[keyof ListBasinsErrors];

export type ListBasinsResponses = {
    200: ListBasinsResponse;
};

export type ListBasinsResponse2 = ListBasinsResponses[keyof ListBasinsResponses];

export type CreateBasinData = {
    body: CreateBasinRequest;
    headers?: {
        /**
         * Client-specified request token for idempotent retries.
         */
        's2-request-token'?: string;
    };
    path?: never;
    query?: never;
    url: '/basins';
};

export type CreateBasinErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
};

export type CreateBasinError = CreateBasinErrors[keyof CreateBasinErrors];

export type CreateBasinResponses = {
    200: BasinInfo;
    201: BasinInfo;
};

export type CreateBasinResponse = CreateBasinResponses[keyof CreateBasinResponses];

export type DeleteBasinData = {
    body?: never;
    path: {
        /**
         * Basin name.
         */
        basin: BasinNameStr;
    };
    query?: never;
    url: '/basins/{basin}';
};

export type DeleteBasinErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
};

export type DeleteBasinError = DeleteBasinErrors[keyof DeleteBasinErrors];

export type DeleteBasinResponses = {
    202: unknown;
};

export type GetBasinConfigData = {
    body?: never;
    path: {
        /**
         * Basin name.
         */
        basin: BasinNameStr;
    };
    query?: never;
    url: '/basins/{basin}';
};

export type GetBasinConfigErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
};

export type GetBasinConfigError = GetBasinConfigErrors[keyof GetBasinConfigErrors];

export type GetBasinConfigResponses = {
    200: BasinConfig;
};

export type GetBasinConfigResponse = GetBasinConfigResponses[keyof GetBasinConfigResponses];

export type ReconfigureBasinData = {
    body: BasinReconfiguration;
    path: {
        /**
         * Basin name.
         */
        basin: BasinNameStr;
    };
    query?: never;
    url: '/basins/{basin}';
};

export type ReconfigureBasinErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
};

export type ReconfigureBasinError = ReconfigureBasinErrors[keyof ReconfigureBasinErrors];

export type ReconfigureBasinResponses = {
    200: BasinConfig;
};

export type ReconfigureBasinResponse = ReconfigureBasinResponses[keyof ReconfigureBasinResponses];

export type CreateOrReconfigureBasinData = {
    body?: null | CreateOrReconfigureBasinRequest;
    path: {
        /**
         * Basin name.
         */
        basin: BasinNameStr;
    };
    query?: never;
    url: '/basins/{basin}';
};

export type CreateOrReconfigureBasinErrors = {
    400: ErrorInfo;
    408: ErrorInfo;
};

export type CreateOrReconfigureBasinError = CreateOrReconfigureBasinErrors[keyof CreateOrReconfigureBasinErrors];

export type CreateOrReconfigureBasinResponses = {
    200: BasinInfo;
    201: BasinInfo;
    204: void;
};

export type CreateOrReconfigureBasinResponse = CreateOrReconfigureBasinResponses[keyof CreateOrReconfigureBasinResponses];

export type AccountMetricsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Metric set to return.
         */
        set: AccountMetricSet;
        /**
         * Start timestamp as Unix epoch seconds, if applicable for the metric set.
         */
        start?: number;
        /**
         * End timestamp as Unix epoch seconds, if applicable for the metric set.
         */
        end?: number;
        /**
         * Interval to aggregate over for timeseries metric sets.
         */
        interval?: TimeseriesInterval;
    };
    url: '/metrics';
};

export type AccountMetricsErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    408: ErrorInfo;
};

export type AccountMetricsError = AccountMetricsErrors[keyof AccountMetricsErrors];

export type AccountMetricsResponses = {
    200: MetricSetResponse;
};

export type AccountMetricsResponse = AccountMetricsResponses[keyof AccountMetricsResponses];

export type BasinMetricsData = {
    body?: never;
    path: {
        /**
         * Basin name.
         */
        basin: BasinNameStr;
    };
    query: {
        /**
         * Metric set to return.
         */
        set: BasinMetricSet;
        /**
         * Start timestamp as Unix epoch seconds, if applicable for the metric set.
         */
        start?: number;
        /**
         * End timestamp as Unix epoch seconds, if applicable for the metric set.
         */
        end?: number;
        /**
         * Interval to aggregate over for timeseries metric sets.
         */
        interval?: TimeseriesInterval;
    };
    url: '/metrics/{basin}';
};

export type BasinMetricsErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    408: ErrorInfo;
};

export type BasinMetricsError = BasinMetricsErrors[keyof BasinMetricsErrors];

export type BasinMetricsResponses = {
    200: MetricSetResponse;
};

export type BasinMetricsResponse = BasinMetricsResponses[keyof BasinMetricsResponses];

export type StreamMetricsData = {
    body?: never;
    path: {
        /**
         * Basin name.
         */
        basin: BasinNameStr;
        /**
         * Stream name.
         */
        stream: StreamNameStr;
    };
    query: {
        /**
         * Metric set to return.
         */
        set: StreamMetricSet;
        /**
         * Start timestamp as Unix epoch seconds, if applicable for the metric set.
         */
        start?: number;
        /**
         * End timestamp as Unix epoch seconds, if applicable for metric set.
         */
        end?: number;
        /**
         * Interval to aggregate over for timeseries metric sets.
         */
        interval?: TimeseriesInterval;
    };
    url: '/metrics/{basin}/{stream}';
};

export type StreamMetricsErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    408: ErrorInfo;
};

export type StreamMetricsError = StreamMetricsErrors[keyof StreamMetricsErrors];

export type StreamMetricsResponses = {
    200: MetricSetResponse;
};

export type StreamMetricsResponse = StreamMetricsResponses[keyof StreamMetricsResponses];

export type ListStreamsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter to streams whose name begins with this prefix.
         */
        prefix?: string;
        /**
         * Filter to streams whose name begins with this prefix.
         * It must be greater than or equal to the `prefix` if specified.
         */
        start_after?: string;
        /**
         * Number of results, up to a maximum of 1000.
         */
        limit?: number;
    };
    url: '/streams';
};

export type ListStreamsErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
};

export type ListStreamsError = ListStreamsErrors[keyof ListStreamsErrors];

export type ListStreamsResponses = {
    200: ListStreamsResponse;
};

export type ListStreamsResponse2 = ListStreamsResponses[keyof ListStreamsResponses];

export type CreateStreamData = {
    body: CreateStreamRequest;
    headers?: {
        /**
         * Client-specified request token for idempotent retries.
         */
        's2-request-token'?: string;
    };
    path?: never;
    query?: never;
    url: '/streams';
};

export type CreateStreamErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
};

export type CreateStreamError = CreateStreamErrors[keyof CreateStreamErrors];

export type CreateStreamResponses = {
    201: StreamInfo;
};

export type CreateStreamResponse = CreateStreamResponses[keyof CreateStreamResponses];

export type DeleteStreamData = {
    body?: never;
    path: {
        /**
         * Stream name.
         */
        stream: StreamNameStr;
    };
    query?: never;
    url: '/streams/{stream}';
};

export type DeleteStreamErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
};

export type DeleteStreamError = DeleteStreamErrors[keyof DeleteStreamErrors];

export type DeleteStreamResponses = {
    202: unknown;
};

export type GetStreamConfigData = {
    body?: never;
    path: {
        /**
         * Stream name.
         */
        stream: StreamNameStr;
    };
    query?: never;
    url: '/streams/{stream}';
};

export type GetStreamConfigErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
};

export type GetStreamConfigError = GetStreamConfigErrors[keyof GetStreamConfigErrors];

export type GetStreamConfigResponses = {
    200: StreamConfig;
};

export type GetStreamConfigResponse = GetStreamConfigResponses[keyof GetStreamConfigResponses];

export type ReconfigureStreamData = {
    body: StreamReconfiguration;
    path: {
        /**
         * Stream name.
         */
        stream: StreamNameStr;
    };
    query?: never;
    url: '/streams/{stream}';
};

export type ReconfigureStreamErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
};

export type ReconfigureStreamError = ReconfigureStreamErrors[keyof ReconfigureStreamErrors];

export type ReconfigureStreamResponses = {
    200: StreamConfig;
};

export type ReconfigureStreamResponse = ReconfigureStreamResponses[keyof ReconfigureStreamResponses];

export type CreateOrReconfigureStreamData = {
    body?: null | StreamConfig;
    path: {
        /**
         * Stream name.
         */
        stream: StreamNameStr;
    };
    query?: never;
    url: '/streams/{stream}';
};

export type CreateOrReconfigureStreamErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
};

export type CreateOrReconfigureStreamError = CreateOrReconfigureStreamErrors[keyof CreateOrReconfigureStreamErrors];

export type CreateOrReconfigureStreamResponses = {
    201: StreamInfo;
    204: void;
};

export type CreateOrReconfigureStreamResponse = CreateOrReconfigureStreamResponses[keyof CreateOrReconfigureStreamResponses];

export type ReadData = {
    body?: never;
    headers?: {
        /**
         * Defines the interpretation of record data (header name, header value, and body) with the JSON content type.
         * Use `raw` (default) for efficient transmission and storage of Unicode data — storage will be in UTF-8.
         * Use `base64` for safe transmission with efficient storage of binary data.
         */
        's2-format'?: Format;
    };
    path: {
        /**
         * Stream name.
         */
        stream: StreamNameStr;
    };
    query?: {
        /**
         * Start from a sequence number.
         */
        seq_num?: U64;
        /**
         * Start from a timestamp.
         */
        timestamp?: U64;
        /**
         * Start from number of records before the next sequence number.
         */
        tail_offset?: number;
        /**
         * Start reading from the tail if the requested position is beyond it.
         * Otherwise, a `416 Range Not Satisfiable` response is returned.
         */
        clamp?: boolean;
        /**
         * Record count limit.
         * Non-streaming reads are capped by the default limit of 1000 records.
         */
        count?: number;
        /**
         * Metered bytes limit.
         * Non-streaming reads are capped by the default limit of 1 MiB.
         */
        bytes?: number;
        /**
         * Exclusive timestamp to read until.
         */
        until?: U64;
        /**
         * Duration in seconds to wait for new records.
         * The default duration is 0 if there is a bound on `count`, `bytes`, or `until`, and otherwise infinite.
         * Non-streaming reads are always bounded on `count` and `bytes`, so you can achieve long poll semantics by specifying a non-zero duration up to 60 seconds.
         * In the context of an SSE or S2S streaming read, the duration will bound how much time can elapse between records throughout the lifetime of the session.
         */
        wait?: number;
    };
    url: '/streams/{stream}/records';
};

export type ReadErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
    416: TailResponse;
};

export type ReadError = ReadErrors[keyof ReadErrors];

export type ReadResponses = {
    200: ReadBatch;
};

export type ReadResponse = ReadResponses[keyof ReadResponses];

export type AppendData = {
    body: AppendInput;
    headers?: {
        /**
         * Defines the interpretation of record data (header name, header value, and body) with the JSON content type.
         * Use `raw` (default) for efficient transmission and storage of Unicode data — storage will be in UTF-8.
         * Use `base64` for safe transmission with efficient storage of binary data.
         */
        's2-format'?: Format;
    };
    path: {
        /**
         * Stream name.
         */
        stream: StreamNameStr;
    };
    query?: never;
    url: '/streams/{stream}/records';
};

export type AppendErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
    412: AppendConditionFailed;
};

export type AppendError = AppendErrors[keyof AppendErrors];

export type AppendResponses = {
    200: AppendAck;
};

export type AppendResponse = AppendResponses[keyof AppendResponses];

export type CheckTailData = {
    body?: never;
    path: {
        /**
         * Stream name.
         */
        stream: StreamNameStr;
    };
    query?: never;
    url: '/streams/{stream}/records/tail';
};

export type CheckTailErrors = {
    400: ErrorInfo;
    403: ErrorInfo;
    404: ErrorInfo;
    408: ErrorInfo;
    409: ErrorInfo;
};

export type CheckTailError = CheckTailErrors[keyof CheckTailErrors];

export type CheckTailResponses = {
    200: TailResponse;
};

export type CheckTailResponse = CheckTailResponses[keyof CheckTailResponses];
