/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/access-tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List access tokens. */
        get: operations["list_access_tokens"];
        put?: never;
        /** Issue a new access token. */
        post: operations["issue_access_token"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/access-tokens/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Revoke an access token. */
        delete: operations["revoke_access_token"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/basins": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List basins. */
        get: operations["list_basins"];
        put?: never;
        /** Create a basin. */
        post: operations["create_basin"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/basins/{basin}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get basin configuration. */
        get: operations["get_basin_config"];
        /** Create or reconfigure a basin. */
        put: operations["create_or_reconfigure_basin"];
        post?: never;
        /** Delete a basin. */
        delete: operations["delete_basin"];
        options?: never;
        head?: never;
        /** Reconfigure a basin. */
        patch: operations["reconfigure_basin"];
        trace?: never;
    };
    "/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Account-level metrics. */
        get: operations["account_metrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics/{basin}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Basin-level metrics. */
        get: operations["basin_metrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics/{basin}/{stream}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Stream-level metrics. */
        get: operations["stream_metrics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/streams": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List streams. */
        get: operations["list_streams"];
        put?: never;
        /** Create a stream. */
        post: operations["create_stream"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/streams/{stream}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get stream configuration. */
        get: operations["get_stream_config"];
        /** Create or reconfigure a stream. */
        put: operations["create_or_reconfigure_stream"];
        post?: never;
        /** Delete a stream. */
        delete: operations["delete_stream"];
        options?: never;
        head?: never;
        /** Reconfigure a stream. */
        patch: operations["reconfigure_stream"];
        trace?: never;
    };
    "/streams/{stream}/records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Read records. */
        get: operations["read"];
        put?: never;
        /** Append records. */
        post: operations["append"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/streams/{stream}/records/tail": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Check the tail. */
        get: operations["check_tail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AccessTokenInfo: {
            /**
             * @description Namespace streams based on the configured stream-level scope, which must be a prefix.
             *     Stream name arguments will be automatically prefixed, and the prefix will be stripped when listing streams.
             * @default false
             */
            auto_prefix_streams: boolean;
            /**
             * Format: time
             * @description Expiration time in ISO 8601 format.
             *     If not set, the expiration will be set to that of the requestor's token.
             */
            expires_at?: string | null;
            /** @description Access token ID.
             *     It must be unique to the account and between 1 and 96 bytes in length. */
            id: string;
            /** @description Access token scope. */
            scope: components["schemas"]["AccessTokenScope"];
        };
        AccessTokenScope: {
            access_tokens?: null | components["schemas"]["ResourceSet"];
            basins?: null | components["schemas"]["ResourceSet"];
            op_groups?: null | components["schemas"]["PermittedOperationGroups"];
            /** @description Operations allowed for the token.
             *     A union of allowed operations and groups is used as an effective set of allowed operations. */
            ops?: components["schemas"]["Operation"][] | null;
            streams?: null | components["schemas"]["ResourceSet"];
        };
        /** @enum {string} */
        AccountMetricSet: "active-basins" | "account-ops";
        Accumulation: {
            /** @description The duration of bucket for the accumulation. */
            bucket_length: components["schemas"]["TimeseriesInterval"];
            /** @description Timeseries name. */
            name: string;
            /** @description Unit of the metric. */
            unit: components["schemas"]["MetricUnit"];
            /** @description Timeseries values.
             *     Each element is a tuple of a timestamp in Unix epoch seconds and a data point.
             *     The data point represents the accumulated value for a bucket of time starting at the provided timestamp, lasting for the duration of the `bucket_length` parameter. */
            values: [
                number,
                number
            ][];
        };
        /** @description Success response to an `append` request. */
        AppendAck: {
            /** @description Sequence number of the last record that was appended `+ 1`, and timestamp of the last record that was appended.
             *     The difference between `end.seq_num` and `start.seq_num` will be the number of records appended. */
            end: components["schemas"]["StreamPosition"];
            /** @description Sequence number and timestamp of the first record that was appended. */
            start: components["schemas"]["StreamPosition"];
            /** @description Sequence number that will be assigned to the next record on the stream, and timestamp of the last record on the stream.
             *     This can be greater than the `end` position in case of concurrent appends. */
            tail: components["schemas"]["StreamPosition"];
        };
        /** @description Aborted due to a failed condition. */
        AppendConditionFailed: {
            /** @description Fencing token did not match.
             *     The expected fencing token is returned. */
            fencing_token_mismatch: string;
        } | {
            /**
             * Format: int64
             * @description Sequence number did not match the tail of the stream.
             *     The expected next sequence number is returned.
             */
            seq_num_mismatch: number;
        };
        /** @description Payload of an `append` request. */
        AppendInput: {
            /** @description Enforce a fencing token, which starts out as an empty string that can be overridden by a `fence` command record. */
            fencing_token?: string | null;
            match_seq_num?: null | components["schemas"]["u64"];
            /** @description Batch of records to append atomically, which must contain at least one record, and no more than 1000.
             *     The total size of a batch of records may not exceed 1 MiB of metered bytes. */
            records: components["schemas"]["AppendRecord"][];
        };
        /** @description Record to be appended to a stream. */
        AppendRecord: {
            /** @description Body of the record. */
            body?: string;
            /** @description Series of name-value pairs for this record. */
            headers?: components["schemas"]["Header"][];
            timestamp?: null | components["schemas"]["u64"];
        };
        BasinConfig: {
            /** @description Create stream on append if it doesn't exist, using the default stream configuration. */
            create_stream_on_append?: boolean;
            /** @description Create stream on read if it doesn't exist, using the default stream configuration. */
            create_stream_on_read?: boolean;
            default_stream_config?: null | components["schemas"]["StreamConfig"];
        };
        BasinInfo: {
            /** @description Basin name. */
            name: string;
            /** @description Basin scope. */
            scope: components["schemas"]["BasinScope"];
            /** @description Basin state. */
            state: components["schemas"]["BasinState"];
        };
        /** @enum {string} */
        BasinMetricSet: "storage" | "append-ops" | "read-ops" | "read-throughput" | "append-throughput" | "basin-ops";
        BasinReconfiguration: {
            /** @description Create a stream on append. */
            create_stream_on_append?: boolean | null;
            /** @description Create a stream on read. */
            create_stream_on_read?: boolean | null;
            default_stream_config?: null | components["schemas"]["StreamReconfiguration"];
        };
        /** @enum {string} */
        BasinScope: "aws:us-east-1";
        /** @enum {string} */
        BasinState: "active" | "creating" | "deleting";
        CreateBasinRequest: {
            /** @description Basin name which must be globally unique.
             *     It can be between 8 and 48 characters in length, and comprise lowercase letters, numbers and hyphens.
             *     It cannot begin or end with a hyphen. */
            basin: string;
            config?: null | components["schemas"]["BasinConfig"];
            /** @default aws:us-east-1 */
            scope: components["schemas"]["BasinScope"];
        };
        CreateOrReconfigureBasinRequest: {
            config?: null | components["schemas"]["BasinConfig"];
            /** @default aws:us-east-1 */
            scope: components["schemas"]["BasinScope"];
        };
        CreateStreamRequest: {
            config?: null | components["schemas"]["StreamConfig"];
            /** @description Stream name that is unique to the basin.
             *     It can be between 1 and 512 bytes in length. */
            stream: string;
        };
        DeleteOnEmptyConfig: {
            /**
             * Format: int64
             * @description Minimum age in seconds before an empty stream can be deleted.
             *     Set to 0 (default) to disable delete-on-empty (don't delete automatically).
             */
            min_age_secs?: number;
        };
        DeleteOnEmptyReconfiguration: {
            /**
             * Format: int64
             * @description Minimum age in seconds before an empty stream can be deleted.
             *     Set to 0 to disable delete-on-empty (don't delete automatically).
             */
            min_age_secs?: number | null;
        };
        ErrorResponse: {
            code?: string | null;
            message: string;
        };
        Gauge: {
            /** @description Timeseries name. */
            name: string;
            /** @description Unit of the metric. */
            unit: components["schemas"]["MetricUnit"];
            /** @description Timeseries values.
             *     Each element is a tuple of a timestamp in Unix epoch seconds and a data point.
             *     The data point represents the value at the instant of the timestamp. */
            values: [
                number,
                number
            ][];
        };
        /** @description Headers add structured information to a record as name-value pairs.
         *
         *     The name cannot be empty, with the exception of an S2 command record. */
        Header: string[];
        InfiniteRetention: Record<string, never>;
        IssueAccessTokenResponse: {
            /** @description Created access token. */
            access_token: string;
        };
        Label: {
            /** @description Label name. */
            name: string;
            /** @description Label values. */
            values: string[];
        };
        ListAccessTokensResponse: {
            /** @description Matching access tokens. */
            access_tokens: components["schemas"]["AccessTokenInfo"][];
            /** @description Indicates that there are more access tokens that match the criteria. */
            has_more: boolean;
        };
        ListBasinsResponse: {
            /** @description Matching basins. */
            basins: components["schemas"]["BasinInfo"][];
            /** @description Indicates that there are more basins that match the criteria. */
            has_more: boolean;
        };
        ListStreamsResponse: {
            /** @description Indicates that there are more results that match the criteria. */
            has_more: boolean;
            /** @description Matching streams. */
            streams: components["schemas"]["StreamInfo"][];
        };
        Metric: {
            /** @description Single named value. */
            scalar: components["schemas"]["Scalar"];
        } | {
            /** @description Named series of `(timestamp, value)` points representing an accumulation over a specified
             *     bucket. */
            accumulation: components["schemas"]["Accumulation"];
        } | {
            /** @description Named series of `(timestamp, value)` points each representing an instantaneous value. */
            gauge: components["schemas"]["Gauge"];
        } | {
            /** @description Set of string labels. */
            label: components["schemas"]["Label"];
        };
        MetricSetResponse: {
            /** @description Metrics comprising the set. */
            values: components["schemas"]["Metric"][];
        };
        /** @enum {string} */
        MetricUnit: "bytes" | "operations";
        /** @enum {string} */
        Operation: "list-basins" | "create-basin" | "delete-basin" | "reconfigure-basin" | "get-basin-config" | "issue-access-token" | "revoke-access-token" | "list-access-tokens" | "list-streams" | "create-stream" | "delete-stream" | "get-stream-config" | "reconfigure-stream" | "check-tail" | "append" | "read" | "trim" | "fence" | "account-metrics" | "basin-metrics" | "stream-metrics";
        PermittedOperationGroups: {
            account?: null | components["schemas"]["ReadWritePermissions"];
            basin?: null | components["schemas"]["ReadWritePermissions"];
            stream?: null | components["schemas"]["ReadWritePermissions"];
        };
        PingEventData: {
            /** Format: int64 */
            timestamp: number;
        };
        ReadBatch: {
            /** @description Records that are durably sequenced on the stream, retrieved based on the requested criteria.
             *     This can only be empty in response to a regular (non-SSE) read, if the request cannot be satisfied without violating an explicit limit. */
            records: components["schemas"]["SequencedRecord"][];
            tail?: null | components["schemas"]["StreamPosition"];
        };
        ReadEvent: {
            data: components["schemas"]["ReadBatch"];
            /** @enum {string} */
            event: "batch";
            id: string;
        } | {
            data: string;
            /** @enum {string} */
            event: "error";
        } | {
            data: components["schemas"]["PingEventData"];
            /** @enum {string} */
            event: "ping";
        };
        ReadWritePermissions: {
            /**
             * @description Read permission.
             * @default false
             */
            read: boolean;
            /**
             * @description Write permission.
             * @default false
             */
            write: boolean;
        };
        ResourceSet: {
            /** @description Match only the resource with this exact name.
             *     Use an empty string to match no resources. */
            exact: string;
        } | {
            /** @description Match all resources that start with this prefix.
             *     Use an empty string to match all resource. */
            prefix: string;
        };
        RetentionPolicy: {
            /**
             * Format: int64
             * @description Age in seconds for automatic trimming of records older than this threshold.
             *     This must be set to a value greater than 0 seconds.
             *     (While S2 is in public preview, this is capped at 28 days. Let us know if you'd like the cap removed.)
             */
            age: number;
        } | {
            /** @description Retain records unless explicitly trimmed. */
            infinite: components["schemas"]["InfiniteRetention"];
        };
        /** @enum {string} */
        S2Format: "raw" | "base64";
        Scalar: {
            /** @description Metric name. */
            name: string;
            /** @description Unit of the metric. */
            unit: components["schemas"]["MetricUnit"];
            /**
             * Format: double
             * @description Metric value.
             */
            value: number;
        };
        /** @description Record that is durably sequenced on a stream. */
        SequencedRecord: {
            /** @description Body of the record. */
            body?: string;
            /** @description Series of name-value pairs for this record. */
            headers?: components["schemas"]["Header"][];
            /** @description Sequence number assigned by the service. */
            seq_num: components["schemas"]["u64"];
            /** @description Timestamp for this record. */
            timestamp: components["schemas"]["u64"];
        };
        /** @enum {string} */
        StorageClass: "standard" | "express";
        StreamConfig: {
            delete_on_empty?: null | components["schemas"]["DeleteOnEmptyConfig"];
            retention_policy?: null | components["schemas"]["RetentionPolicy"];
            storage_class?: null | components["schemas"]["StorageClass"];
            timestamping?: null | components["schemas"]["TimestampingConfig"];
        };
        StreamInfo: {
            /**
             * Format: time
             * @description Creation time in ISO 8601 format.
             */
            created_at: string;
            /**
             * Format: time
             * @description Deletion time in ISO 8601 format, if the stream is being deleted.
             */
            deleted_at?: string | null;
            /** @description Stream name. */
            name: string;
        };
        /** @enum {string} */
        StreamMetricSet: "storage";
        /** @description Position of a record in a stream. */
        StreamPosition: {
            /**
             * Format: int64
             * @description Sequence number assigned by the service.
             */
            seq_num: number;
            /**
             * Format: int64
             * @description Timestamp, which may be client-specified or assigned by the service.
             *     If it is assigned by the service, it will represent milliseconds since Unix epoch.
             */
            timestamp: number;
        };
        StreamReconfiguration: {
            delete_on_empty?: null | components["schemas"]["DeleteOnEmptyReconfiguration"];
            retention_policy?: null | components["schemas"]["RetentionPolicy"];
            storage_class?: null | components["schemas"]["StorageClass"];
            timestamping?: null | components["schemas"]["TimestampingReconfiguration"];
        };
        TailResponse: {
            /** @description Sequence number that will be assigned to the next record on the stream, and timestamp of the last record. */
            tail: components["schemas"]["StreamPosition"];
        };
        /** @enum {string} */
        TimeseriesInterval: "minute" | "hour" | "day";
        TimestampingConfig: {
            mode?: null | components["schemas"]["TimestampingMode"];
            /** @description Allow client-specified timestamps to exceed the arrival time.
             *     If this is `false` or not set, client timestamps will be capped at the arrival time. */
            uncapped?: boolean | null;
        };
        /** @enum {string} */
        TimestampingMode: "client-prefer" | "client-require" | "arrival";
        TimestampingReconfiguration: {
            mode?: null | components["schemas"]["TimestampingMode"];
            /** @description Allow client-specified timestamps to exceed the arrival time. */
            uncapped?: boolean | null;
        };
        /** Format: int64 */
        u64: number;
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    list_access_tokens: {
        parameters: {
            query?: {
                /** @description Filter to access tokens whose ID begins with this prefix. */
                prefix?: string;
                /** @description Filter to access tokens whose ID lexicographically starts after this string. */
                start_after?: string;
                /** @description Number of results, up to a maximum of 1000. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListAccessTokensResponse"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    issue_access_token: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AccessTokenInfo"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IssueAccessTokenResponse"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    revoke_access_token: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Access token ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    list_basins: {
        parameters: {
            query?: {
                /** @description Filter to basins whose names begin with this prefix. */
                prefix?: string;
                /** @description Filter to basins whose names lexicographically start after this string.
                 *     It must be greater than or equal to the `prefix` if specified. */
                start_after?: string;
                /** @description Number of results, up to a maximum of 1000. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListBasinsResponse"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    create_basin: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateBasinRequest"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BasinInfo"];
                };
            };
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BasinInfo"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    get_basin_config: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Basin name. */
                basin: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BasinConfig"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    create_or_reconfigure_basin: {
        parameters: {
            query?: never;
            header?: {
                /** @description Client-specified request token for idempotent retries. */
                "s2-request-token"?: string;
            };
            path: {
                /** @description Basin name. */
                basin: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": null | components["schemas"]["CreateOrReconfigureBasinRequest"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BasinInfo"];
                };
            };
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BasinInfo"];
                };
            };
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    delete_basin: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Basin name. */
                basin: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    reconfigure_basin: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Basin name. */
                basin: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BasinReconfiguration"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BasinConfig"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    account_metrics: {
        parameters: {
            query: {
                /** @description Metric set to return. */
                set: components["schemas"]["AccountMetricSet"];
                /** @description Start timestamp as Unix epoch seconds, if applicable for the metric set. */
                start?: number;
                /** @description End timestamp as Unix epoch seconds, if applicable for the metric set. */
                end?: number;
                /** @description Interval to aggregate over for timeseries metric sets. */
                interval?: components["schemas"]["TimeseriesInterval"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetricSetResponse"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    basin_metrics: {
        parameters: {
            query: {
                /** @description Metric set to return. */
                set: components["schemas"]["BasinMetricSet"];
                /** @description Start timestamp as Unix epoch seconds, if applicable for the metric set. */
                start?: number;
                /** @description End timestamp as Unix epoch seconds, if applicable for the metric set. */
                end?: number;
                /** @description Interval to aggregate over for timeseries metric sets. */
                interval?: components["schemas"]["TimeseriesInterval"];
            };
            header?: never;
            path: {
                /** @description Basin name. */
                basin: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetricSetResponse"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    stream_metrics: {
        parameters: {
            query: {
                /** @description Metric set to return. */
                set: components["schemas"]["StreamMetricSet"];
                /** @description Start timestamp as Unix epoch seconds, if applicable for the metric set. */
                start?: number;
                /** @description End timestamp as Unix epoch seconds, if applicable for metric set. */
                end?: number;
                /** @description Interval to aggregate over for timeseries metric sets. */
                interval?: components["schemas"]["TimeseriesInterval"];
            };
            header?: never;
            path: {
                /** @description Basin name. */
                basin: string;
                /** @description Stream name. */
                stream: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetricSetResponse"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    list_streams: {
        parameters: {
            query?: {
                /** @description Filter to streams whose name begins with this prefix. */
                prefix?: string;
                /** @description Filter to streams whose name begins with this prefix.
                 *     It must be greater than or equal to the `prefix` if specified. */
                start_after?: string;
                /** @description Number of results, up to a maximum of 1000. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListStreamsResponse"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    create_stream: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateStreamRequest"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreamInfo"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    get_stream_config: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Stream name. */
                stream: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreamConfig"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    create_or_reconfigure_stream: {
        parameters: {
            query?: never;
            header?: {
                /** @description Client-specified request token for idempotent retries. */
                "s2-request-token"?: string;
            };
            path: {
                /** @description Stream name. */
                stream: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": null | components["schemas"]["StreamConfig"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreamInfo"];
                };
            };
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    delete_stream: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Stream name. */
                stream: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    reconfigure_stream: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Stream name. */
                stream: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StreamReconfiguration"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreamConfig"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    read: {
        parameters: {
            query?: {
                /** @description Start from a sequence number. */
                seq_num?: components["schemas"]["u64"];
                /** @description Start from a timestamp. */
                timestamp?: components["schemas"]["u64"];
                /** @description Start from number of records before the next sequence number. */
                tail_offset?: number;
                /** @description Start reading from the tail if the requested position is beyond it.
                 *     Otherwise, a `416 Range Not Satisfiable` response is returned. */
                clamp?: boolean;
                /** @description Record count limit.
                 *     Non-streaming reads are capped by the default limit of 1000 records. */
                count?: number;
                /** @description Metered bytes limit.
                 *     Non-streaming reads are capped by the default limit of 1 MiB. */
                bytes?: number;
                /** @description Exclusive timestamp to read until. */
                until?: components["schemas"]["u64"];
                /** @description Duration in seconds to wait for new records.
                 *     The default duration is 0 if there is a bound on `count`, `bytes`, or `until`, and otherwise infinite.
                 *     Non-streaming reads are always bounded on `count` and `bytes`, so you can achieve long poll semantics by specifying a non-zero duration up to 60 seconds.
                 *     In the context of an SSE or S2S streaming read, the duration will bound how much time can elapse between records throughout the lifetime of the session. */
                wait?: number;
            };
            header?: {
                /** @description Defines the interpretation of record data (header name, header value, and body) with the JSON content type.
                 *     Use `raw` (default) for efficient transmission and storage of Unicode data  storage will be in UTF-8.
                 *     Use `base64` for safe transmission with efficient storage of binary data. */
                "s2-format"?: components["schemas"]["S2Format"];
            };
            path: {
                /** @description Stream name. */
                stream: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReadBatch"];
                    "text/event-stream": components["schemas"]["ReadEvent"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            416: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TailResponse"];
                };
            };
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    append: {
        parameters: {
            query?: never;
            header?: {
                /** @description Defines the interpretation of record data (header name, header value, and body) with the JSON content type.
                 *     Use `raw` (default) for efficient transmission and storage of Unicode data  storage will be in UTF-8.
                 *     Use `base64` for safe transmission with efficient storage of binary data. */
                "s2-format"?: components["schemas"]["S2Format"];
            };
            path: {
                /** @description Stream name. */
                stream: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AppendInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppendAck"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            412: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppendConditionFailed"];
                };
            };
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    check_tail: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Stream name. */
                stream: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TailResponse"];
                };
            };
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
}
